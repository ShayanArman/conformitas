import type { BatchEmailsWorkflow, CleanEmailsWorkflow, MoveEmailsWorkflow } from "types/objects/composites/workflowsPlusPayloads";
import type { BatchEmailsPayload, MoveEmailsPayload } from "types/objects/payloads/workflows";
import { OutlookEmailAgent } from "@server/workflows/functions/batchEmails/OutlookBatchAgent";
import { GoogleEmailAgent } from "@server/workflows/functions/batchEmails/GoogleBatchAgent";
import WorkflowManager from "@server/services/workflows/WorkflowManager";
import * as taskActions from "@server/db/DynamoDB/actions/taskActions";
import { TaskStatus, type TaskItem } from "types/objects/tasks";
import { ResourceProvider } from "types/resources/resources";
import type { ProtectedContext } from "@server/trpc/context";
import * as dynamoActions from "@server/db/DynamoDB/actions";
import * as EmailApiResource from "types/providers/emailApi";
import * as dynamoTables from "@server/db/DynamoDB/tables";
import type { UserAccountItem } from "types/objects/user";
import * as Workflows from "types/objects/workflows";
import { DynamoTable } from "types/objects/tables";

export type WorkflowStatusPlusStale = Workflows.WorkflowStatus | "Stale";

export class ResourceInUseException extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ResourceInUseException";
  }
}

// todo can-ship move to Types **after code is tried-and-tested in prod.
export type CleaningAgentState = {
  latestCleanEmailsWorkflow: CleanEmailsWorkflow;

  // If Batch is ERROR or STOPPED or Stale we create a new Agent.
  // If ONGOING or COMPLETED we show OPEN Tasks to user.
  batchStatus: WorkflowStatusPlusStale;

  // Only if Batch is COMPLETED should this be anything other than NOT_STARTED
  // If Move is ERROR or STOPPED we simply restart it.
  // Whatever state it is in, and Batch COMPLETED we show OPEN Tasks to User.
  moveStatus?: WorkflowStatusPlusStale;

  // Null means no agent exists yet. None ever created
  // Ongoing means the process is in a Good state and running.
  // STOPPED means Batch either errored or stopped for some reason. Restart here means make new agent.
  // Completed: good, we finished 'x' time ago. Restart-> make new agent.
  // derivedState: "NOT_STARTED" | "ONGOING" | "STOPPED" | "COMPLETED" | "STALE";

  userTasks: TaskItem[]; // OPEN Tasks for User
  // include later just show skeleton for now batchEvents: WorkflowEvent[]; // limit to 10 most recent
  // include later just show skeleton for now moveEvents: WorkflowEvent[]; // limit to 10 most recent
};

export class EmailCleaningAgent {
  private workflowManager: WorkflowManager;
  private taskManager: TaskManager;

  private constructor(private ctx: ProtectedContext) {
    this.workflowManager = new WorkflowManager(ctx);
    this.taskManager = new TaskManager(ctx);
  }

  // only way to Create a EmailCleaningAgent object.
  static async instantiate(ctx: ProtectedContext): Promise<EmailCleaningAgent> {
    const agent = new EmailCleaningAgent(ctx);
    await agent._initialize();
    return agent;
  }

  private async _initialize(): Promise<void> {
    // **warning **do-not-ship after we tackle on a new task, we might have to 're-sync'
    await this._sync();
  }

  // Starting Point -> creates a new Cleaner if None exist and starts it.
  async create(): Promise<void> {
    try {
      const latestEmailCleaner: CleanEmailsWorkflow | null = await this._fetchLatestEmailCleaningWorkflow();

      // 1. Public method ONLY allows others to "create" when there is NO EmailCleaning i.e null.
      // otherwise external must call `restart`
      if (latestEmailCleaner !== null && latestEmailCleaner.workflowId.length > 0) {
        throw new Error(`Cant call <create> when there is already a EmailCleaner Workflow (id): ${latestEmailCleaner.workflowId}`);
      }

      return await this._createAndStartCleaner();
    } catch (error) {
      console.error("Error creating EmailCleaningAgent:", error);
      throw error;
    }
  }

  /**
   * (mutating) (create new CleanEmailsWorkflow)
   * Restart Stops the Agent, and creates a new one.
   */
  async restart(): Promise<void> {
    const _stopLatestEmailCleaner = async ({ latestEmailCleaner }: { latestEmailCleaner: CleanEmailsWorkflow }): Promise<boolean> => {
      try {
        const batchWorkflow: BatchEmailsWorkflow | null = await this.workflowManager.queryLatestChildWorkflowBy<BatchEmailsWorkflow>({
          triggeredById: latestEmailCleaner.workflowId,
          skBeginsWith: `${Workflows.WorkflowType.BatchEmails}`
        });
        if (!batchWorkflow) { return true; }

        const batchStatus = WorkflowManager.getWorkflowStatus({ workflowItem: batchWorkflow });
        switch (batchStatus) {
          case Workflows.WorkflowStatus.NotStarted:
            throw new Error("Should never have a batchEmails workflow in NotStarted state.");
          case Workflows.WorkflowStatus.Error:
          case Workflows.WorkflowStatus.Stopped:
            return true;
          case Workflows.WorkflowStatus.Ongoing:
          case "Stale":
            // actually stop the workflow. then return true;
            await this.workflowManager.stopWorkflow({ workflowItem: batchWorkflow, stopReason: "restart cleaner" });
            return true;
          case Workflows.WorkflowStatus.Completed:
            break; // we must now check if there is any ongoing Move Workflows to stop.
          default:
            const exhaustiveCheck: never = batchStatus;
            throw new Error(`Unhandled workflowStatus case: ${exhaustiveCheck}`);
        }

        const moveWorkflow: MoveEmailsWorkflow | null = await this.workflowManager.queryLatestChildWorkflowBy<MoveEmailsWorkflow>({
          triggeredById: latestEmailCleaner.workflowId,
          skBeginsWith: `${Workflows.WorkflowType.MoveEmails}`
        });
        if (!moveWorkflow) { return true; }

        const moveStatus = WorkflowManager.getWorkflowStatus({ workflowItem: moveWorkflow });
        switch (moveStatus) {
          case Workflows.WorkflowStatus.NotStarted:
            throw new Error("Should never have a moveEmails workflow in NotStarted state.");
          case Workflows.WorkflowStatus.Error:
          case Workflows.WorkflowStatus.Stopped:
          case Workflows.WorkflowStatus.Completed:
            return true;
          case Workflows.WorkflowStatus.Ongoing:
          case "Stale":
            // actually stop the workflow. then return true;
            await this.workflowManager.stopWorkflow({ workflowItem: moveWorkflow, stopReason: "restart cleaner" });
            return true;
          default:
            const exhaustiveCheck: never = moveStatus;
            throw new Error(`Unhandled workflowStatus case: ${exhaustiveCheck}`);
        }
      } catch (error) {
        throw error;
      }
    }

    try {
      const latestEmailCleaner: CleanEmailsWorkflow | null = await this._fetchLatestEmailCleaningWorkflow();

      if (latestEmailCleaner === null) {
        throw new Error(`cannot restart when there is no email cleaner to start...`);
      }

      const isStopped = await _stopLatestEmailCleaner({ latestEmailCleaner });
      if (!isStopped) {
        throw new Error(`Unable to restart, as we could not stop Email Cleaner Workflow`);
      }

      await this._createAndStartCleaner();
      return;
    } catch (error) {
      throw error;
    }
  }

  /**
   * pure, non-mutating
   * @returns { null if no CleanEmails workflow }
   * @returns { CleaningAgentState }
   */
  async getState(): Promise<CleaningAgentState | null> {
    try {
      const latestEmailCleaner: CleanEmailsWorkflow | null = await this._fetchLatestEmailCleaningWorkflow();

      if (!latestEmailCleaner) {
        return null;
      }

      // this should never happen. we instantly `start` batch cleaning after creating a EmailCleaner.
      const batchWorkflow = await this.workflowManager.queryLatestChildWorkflowBy<BatchEmailsWorkflow>({ triggeredById: latestEmailCleaner.workflowId, skBeginsWith: `${Workflows.WorkflowType.BatchEmails}` });
      if (!batchWorkflow) {
        throw new Error(`getState this should never happen. we instantly start batch cleaning after creating a EmailCleaner.`)
      }

      const batchStatus = WorkflowManager.getWorkflowStatus({ workflowItem: batchWorkflow });

      // only if batch is Completed, do we then start the Move process.
      // because if Batch Errors, then we have to Restart
      switch (batchStatus) {
        case Workflows.WorkflowStatus.Error:
        case Workflows.WorkflowStatus.Stopped:
        case Workflows.WorkflowStatus.NotStarted:
        case "Stale":
          return {
            latestCleanEmailsWorkflow: latestEmailCleaner,
            batchStatus,
            moveStatus: undefined,
            userTasks: []
          };
        case Workflows.WorkflowStatus.Ongoing:
        case Workflows.WorkflowStatus.Completed:
          break;
        default:
          const exhaustiveCheck: never = batchStatus;
          throw new Error(`Unhandled workflowType case: ${exhaustiveCheck}`);
      }

      // if batch is Completed, we consider that the batching process is done.
      // then we must check if there are any open tasks. if not, then we consider the entire email cleaning process done.
      // At this point: batch is either Ongoing or Completed

      // Fetch open user tasks (these exist regardless of batch status once batching starts)
      const userTasks = await this._getOpenUserTasks();

      if (batchStatus === Workflows.WorkflowStatus.Ongoing) {
        return {
          latestCleanEmailsWorkflow: latestEmailCleaner,
          batchStatus,
          moveStatus: undefined, // Move hasn't started yet
          userTasks,
        };
      }

      // batchEmailsStatus === Completed
      const moveWorkflow = await this.workflowManager.queryLatestChildWorkflowBy<MoveEmailsWorkflow>({ triggeredById: latestEmailCleaner.workflowId, skBeginsWith: `${Workflows.WorkflowType.MoveEmails}` });
      return {
        latestCleanEmailsWorkflow: latestEmailCleaner,
        batchStatus,
        // if MoveEmails hasn't started yet, send undefined.
        moveStatus: moveWorkflow ? WorkflowManager.getWorkflowStatus({ workflowItem: moveWorkflow }) : undefined,
        userTasks,
      };
    } catch (error) {
      throw error;
    }
  }

  private async _sync(): Promise<void> {
    try {
      const latestEmailCleaner = await this._fetchLatestEmailCleaningWorkflow();
      if (!latestEmailCleaner) { return; }

      const batchWorkflow = await this.workflowManager.queryLatestChildWorkflowBy<BatchEmailsWorkflow>({ triggeredById: latestEmailCleaner.workflowId, skBeginsWith: `${Workflows.WorkflowType.BatchEmails}` });
      if (!batchWorkflow) { return; }

      const batchStatus = WorkflowManager.getWorkflowStatus({ workflowItem: batchWorkflow });

      // Logic: Only move if batching is totally finished
      if (batchStatus !== Workflows.WorkflowStatus.Completed) { return; }

      // shayan-next warning** todo do-not-ship review this OPEN or READY?
      const openTasks = await this.taskManager.getTasks({ ownerId: latestEmailCleaner.workflowId, taskStatus: TaskStatus.Open, limit: 25 });
      // shayan-next warning** todo do-not-ship review this OPEN or READY? REEDY then move??

      if (openTasks.length === 0) { return; }

      // At this point: batch is completed and there are open tasks. We need a Mover.
      const latestMoveWorkflow = await this.workflowManager.queryLatestChildWorkflowBy<MoveEmailsWorkflow>({ triggeredById: latestEmailCleaner.workflowId, skBeginsWith: `${Workflows.WorkflowType.MoveEmails}` });

      if (latestMoveWorkflow) {
        const moveStatus = WorkflowManager.getWorkflowStatus({ workflowItem: latestMoveWorkflow });

        switch (moveStatus) {
          case Workflows.WorkflowStatus.Ongoing:
            return;
          case "Stale":
            await this.workflowManager.stopWorkflow({ workflowItem: latestMoveWorkflow, stopReason: "stale" });
            break;
          case Workflows.WorkflowStatus.Completed:
          case Workflows.WorkflowStatus.Error:
          case Workflows.WorkflowStatus.Stopped:
            break;
          case Workflows.WorkflowStatus.NotStarted:
            throw new Error(`We should never have a NotStarted state for a MoveWorkflow ID: ${latestMoveWorkflow.workflowId}`)
          default:
            const exhaustiveCheck: never = moveStatus;
            throw new Error(`Unhandled move.workflowStatus case: ${exhaustiveCheck}`);
        }
      }

      // **warning todo do-not-ship handle the case where we 'sync' but cannot aquire resources.
      // if so we should figure out what to do...
      try {
        await this._createAndStartMoving({ emailCleaner: latestEmailCleaner });
      } catch (error) {
        // if it is just a Resource in Use Error, we can perhaps skip this?
        throw error;
      }

      return;
    } catch (error) {
      throw error;
    }
  }

  private async _createAndStartCleaner(): Promise<void> {
    const createEmailCleanerWorkflow = async (): Promise<CleanEmailsWorkflow> => {
      try {
        const userId: string = this.ctx.session.user.id;

        // 1. Get user's account to determine provider and providerAccountId
        const userAccountItem: UserAccountItem = await this.ctx.getMyAccount();

        // 2. Generate Cleaner Resource (email provider id) key
        const skParams: Workflows.WorkflowSKParams | null = EmailApiResource.generateWorkflowSk({
          workflowType: Workflows.WorkflowType.CleanEmails,
          userAccountItem,
          option: "create"
        });

        if (!skParams) {
          throw new Error(
            `Unable to generate ${Workflows.WorkflowType.CleanEmails} workflow sk for option: create`,
          );
        }

        // not actually locked or even checked if it exists. that happens at start.
        const resourceLock = EmailApiResource.generateResourceLock({ userAccountItem });

        if (!resourceLock) {
          throw new Error(`Backend error. Unable to make Email API Lock for user: ${userId}`);
        }

        const baseProps: Workflows.BaseWorkflowProps = {
          entityId: userId,
          entityType: Workflows.EntityType.UserPersonal,

          workflowType: Workflows.WorkflowType.CleanEmails,

          resourceType: skParams.resourceType,
          resourceProvider: skParams.resourceProvider,
          resourceAddress: skParams.resourceAddress,

          resourceLocation: EmailApiResource.generateResourceLocation({ userAccountItem }),

          triggerSourceId: userId,
          triggerType: Workflows.TriggerType.UserAction,
          resourceLocks: [resourceLock],
        };

        const { status: createCleanerStatus, workflow: createdCleanerWorkflow } = await dynamoActions.createWorkflow<CleanEmailsWorkflow>({
          ctx: this.ctx,
          baseProps,
        });

        if (createCleanerStatus !== "success" || !createdCleanerWorkflow) {
          throw new Error(`Unable to make emailCleaning workflow for user ${userId}`);
        }

        return createdCleanerWorkflow;
      } catch (error) {
        console.error("Error creating EmailCleaningAgent:", error);
        throw error;
      }
    }

    let latestEmailCleaner: CleanEmailsWorkflow;
    try {
      latestEmailCleaner = await createEmailCleanerWorkflow();
    } catch (error) {
      throw error;
    }

    try {
      await this._createAndStartBatching({ emailCleaner: latestEmailCleaner });
      return;
    } catch (error) {
      // The start failed unexpectedly. Clean up the mess.
      await this.workflowManager.deleteWorkflow({ workflowItem: latestEmailCleaner });
      throw error;
    }
  }

  // **remaining startBatchEmailsWorkflow
  private async _createAndStartBatching({ emailCleaner }: { emailCleaner: CleanEmailsWorkflow }): Promise<BatchEmailsWorkflow> {
    const _createChildWorkflow = async ({ emailCleaner }: { emailCleaner: CleanEmailsWorkflow }): Promise<BatchEmailsWorkflow> => {
      try {
        const baseProps: Workflows.BaseWorkflowProps = {
          workflowType: Workflows.WorkflowType.BatchEmails,
          triggerSourceId: emailCleaner.workflowId,
          triggerType: Workflows.TriggerType.Workflow,

          entityId: emailCleaner.entityId,
          entityType: emailCleaner.entityType,
          resourceType: emailCleaner.resourceType,
          resourceProvider: emailCleaner.resourceProvider,
          resourceAddress: emailCleaner.resourceAddress,
          resourceLocation: emailCleaner.resourceLocation,
          resourceLocks: emailCleaner.resourceLocks,
        };

        const batchPayload: BatchEmailsPayload = {
          emailsProcessed: 0,
          startedAtCursor: null,
          cursor: null,
        }

        const { status: createStatus, workflow: createdWorkflow } = await dynamoActions.createWorkflow<BatchEmailsWorkflow>({
          ctx: this.ctx,
          baseProps,
          payload: batchPayload
        });

        if (createStatus !== "success" || !createdWorkflow) {
          throw new Error(`Unable to make batchEmails workflow for user ${this.ctx.session.user.id}`);
        }

        return createdWorkflow;
      } catch (error) {
        console.error("Error creating BatchEmails Workflow:", error);
        throw error;
      }
    }
    const _startWorkflow = async ({ workflowItem }: { workflowItem: BatchEmailsWorkflow }): Promise<BatchEmailsWorkflow> => {
      try {
        const provider: ResourceProvider = workflowItem.resourceProvider;
        if (provider === ResourceProvider.Google) {
          // todo do-not-ship wrap this agent instantiation around a try catch run onComplete error?
          const agent: GoogleEmailAgent = await GoogleEmailAgent.instantiate(this.ctx);
          // todo do-not-ship next up make onComplete function in workflowManager??
          lambdaToRun = () => { console.log("Moving Google Emails"); }
        } else if (provider === ResourceProvider.Outlook) {
          // todo do-not-ship wrap this agent instantiation around a try catch run onComplete error?
          const agent: OutlookEmailAgent = await OutlookEmailAgent.instantiate(this.ctx);
          // todo do-not-ship next up make onComplete function in workflowManager??
          lambdaToRun = () => { console.log("Moving Outlook Emails"); }
        } else {
          // todo do-not-ship wrap this agent instantiation around a try catch run onComplete error?
          throw new Error(`Unhandled Resource Provider: ${provider}`);
        }
        // based on provider we start the correct batch lambda.
        const startedWorkflow: BatchEmailsWorkflow = await this.workflowManager.startWorkflow<BatchEmailsWorkflow>({
          workflowItem,
          lambdaToRun:
        });
        return startedWorkflow;
      } catch (error) {
        throw error;
      }
    }

    let childWorkflow;
    try {
      childWorkflow = await _createChildWorkflow({ emailCleaner });
    } catch (error) {
      throw error;
    }

    try {
      const startedWorkflow = await _startWorkflow({ workflowItem: childWorkflow });
      return startedWorkflow;
    } catch (error) {
      // The start failed unexpectedly. Clean up the mess.
      await this.workflowManager.deleteWorkflow({ workflowItem: childWorkflow });
      throw error;
    }
  }

  // **remaining startMoveEmailsWorkflow
  private async _createAndStartMoving({ emailCleaner }: { emailCleaner: CleanEmailsWorkflow }): Promise<MoveEmailsWorkflow> {
    const _createChildWorkflow = async ({ emailCleaner }: { emailCleaner: CleanEmailsWorkflow }): Promise<MoveEmailsWorkflow> => {
      try {
        const baseProps: Workflows.BaseWorkflowProps = {
          workflowType: Workflows.WorkflowType.MoveEmails,
          triggerSourceId: emailCleaner.workflowId,
          triggerType: Workflows.TriggerType.Workflow,

          entityId: emailCleaner.entityId,
          entityType: emailCleaner.entityType,
          resourceType: emailCleaner.resourceType,
          resourceProvider: emailCleaner.resourceProvider,
          resourceAddress: emailCleaner.resourceAddress,
          resourceLocation: emailCleaner.resourceLocation,
          resourceLocks: emailCleaner.resourceLocks,
        };

        const movePayload: MoveEmailsPayload = {
          emailsArchived: 0,
          emailsMoved: 0,
          emailsDeleted: 0,
          cursor: null
        }

        const { status: createStatus, workflow: createdWorkflow } = await dynamoActions.createWorkflow<MoveEmailsWorkflow>({
          ctx: this.ctx,
          baseProps,
          payload: movePayload
        });

        if (createStatus !== "success" || !createdWorkflow) {
          throw new Error(`Unable to make moveEmails workflow for user ${this.ctx.session.user.id}`);
        }

        return createdWorkflow;
      } catch (error) {
        console.error("Error creating MoveEmails Workflow:", error);
        throw error;
      }
    }
    const _startWorkflow = async ({ workflowItem }: { workflowItem: MoveEmailsWorkflow }): Promise<MoveEmailsWorkflow> => {
      try {
        const provider: ResourceProvider = workflowItem.resourceProvider;
        let lambdaToRun;
        if (provider === ResourceProvider.Google) {
          lambdaToRun = () => { console.log("Moving Google Emails"); }
        } else if (provider === ResourceProvider.Outlook) {
          lambdaToRun = () => { console.log("Moving Outlook Emails"); }
        } else {
          throw new Error(`Unhandled Resource Provider: ${provider}`);
        }
        const startedWorkflow = await this.workflowManager.startWorkflow<MoveEmailsWorkflow>({
          workflowItem,
          lambdaToRun
        });
        return startedWorkflow;
      } catch (error) {
        throw error;
      }
    }

    let childWorkflow;
    try {
      childWorkflow = await _createChildWorkflow({ emailCleaner });
    } catch (error) {
      throw error;
    }

    try {
      const startedWorkflow = await _startWorkflow({ workflowItem: childWorkflow });
      return startedWorkflow;
    } catch (error) {
      // The start failed unexpectedly. Clean up the mess.
      await this.workflowManager.deleteWorkflow({ workflowItem: childWorkflow });
      throw error;
    }
  }

  private async _fetchLatestEmailCleaningWorkflow(): Promise<CleanEmailsWorkflow | null> {
    try {
      const userId = this.ctx.session.user.id;
      const userAccountItem: UserAccountItem = await this.ctx.getMyAccount();

      // 2. Generate Cleaner Resource (email provider id) key
      const skParams: Workflows.WorkflowSKParams | null = EmailApiResource.generateWorkflowSk({
        workflowType: Workflows.WorkflowType.CleanEmails,
        userAccountItem,
        option: "fetch"
      });

      if (!skParams) {
        throw new Error(
          `Unable to generate ${Workflows.WorkflowType.CleanEmails} workflow sk for option: fetch`,
        );
      }

      // 4. Query DynamoDB for latest workflow
      const { status, items } = await dynamoActions.queryItemsByPrefix<CleanEmailsWorkflow>({
        table: DynamoTable.entityWorkflows,
        pkName: dynamoTables.ENTITY_WORKFLOWS_PK,
        pkValue: userId,
        skName: dynamoTables.ENTITY_WORKFLOWS_SK,
        skPrefix: Workflows.generateSk({ ...skParams }),
        limit: 1,
        scanIndexForward: false, // descending order to get latest
      });

      if (status !== "success") { throw new Error("Unable to fetch latest EmailCleaner item"); }

      return (items && items.length > 0 && items[0]) ? items[0] as CleanEmailsWorkflow : null;
    } catch (error) {
      throw error;
    }
  }
}

// *warning todo_post_launch put resource gain and loss in a reversible Transaction.
// export async function endWorkflow<T>(
//   { ctx, workflow, endState, stopReason, updates }:
//   { ctx: ProtectedContext, workflow: WorkflowItem, endState: "finish" | "stop" | "error"; stopReason?: string; updates: Partial<T>}
// ): Promise<{ status: "success" | "error", updatedWorkflow: WorkflowItem | null }> {
//   try {
//     // leave Undefined. undefined means we keep status if it was already stopped.
//     let newState: WorkflowStatus | undefined = undefined;

//     if (endState === "finish") {
//       newState = WorkflowStatus.Completed;
//     } else if (endState === "error") {
//       newState = WorkflowStatus.Error;
//     } else if (endState === "stop" && [WorkflowStatus.Ongoing, WorkflowStatus.NotStarted].includes(workflow.status)) {
//       newState = WorkflowStatus.Stopped;
//     }

//     // so what does it mean to 'Stop'?
//     // 1. Make sure execution is Fully Stopped. (new invokeId)
//     const { status: updateWorkflowStatus, item: updatedWorkflow } = await updateWorkflow<WorkflowItem>({ ctx, workflow, updates: { ...updates, invokeId: crypto.randomUUID(), status: newState ?? undefined, externalActions: WorkflowAction.Stop ?? undefined, stopReason }})

//     if (updateWorkflowStatus !== "success" || updatedWorkflow === null) {
//       return { status: updateWorkflowStatus, updatedWorkflow: null };
//     }

//     // 2. Resources are Relinquished.
//     const { status: cleanUpStatus } = await cleanUpWorkflowResources({ ctx, workflow: updatedWorkflow });

//     if (cleanUpStatus !== "success") {
//       throw new Error("Error Orchestrator attempting to Complete workflow.")
//     }

//     // Email User when Workflow is Finished. Not when Done. Or Error. (perhaps change this in Future).
//     if (endState === "finish") {
//       // make unique because a workflow might run and restart multiple times.
//       await dynamoActions.createWorkflowEvent({ ctx, workflowId: workflow.workflowId, eventType: EventType.WorkflowFinished, addTimeStamp: true, eventPayload: { description: "finished workflow"} });
//       try {
//         // workflow succesfully finished, send email to user to let them know,
//         await dynamoActions.createScheduledEmailEvent({
//           userId: ctx.session.user.id,
//           workflowId: workflow.workflowId,
//           scheduledAt: new Date().toISOString(),
//           recipientIds: [ctx.session.user.email ?? ''],
//           template: `<html>
//             <body>
//               <h1>Your ${workflow.workflowType} workflow has completed!</h1>
//               <p>Thank you for using ZeroInbox. Your workflow has successfully finished processing.</p>
//             </body>
//           </html>`,
//           // LAUNCH_TODO_P0_CAL, let's do this from a single known domain: workflows@zeroinbox.ai
//           fromEmail: `${workflow.workflowType}@zeroinbox.ai`,
//           subject: `Your ${workflow.workflowType} workflow has completed!`,
//           attachmentKeys: ('s3Keys' in workflow && Array.isArray(workflow.s3Keys) && workflow.s3Keys.every((item) => typeof item === 'string')) ? workflow.s3Keys : undefined,
//         })
//       } catch (emailError) {
//         ctx.logger.error("Error sending completion email:", emailError);
//       }
//     }

//     return { status: "success", updatedWorkflow };
//   } catch (error) {
//     return { status: "error", updatedWorkflow: null };
//   }
// }



async function onComplete({ 
  ctx, 
  workflowItem, 
  exitStatus 
}: { 
  ctx: ProtectedContext; 
  workflowItem: Workflows.WorkflowItem; 
  exitStatus: Workflows.ExitStatus 
}): Promise<void> {
  try {
    // Fetch the latest workflow state to check current status
    const { status: fetchStatus, item: latestWorkflow } = await dynamoActions.fetchItem<Workflows.WorkflowItem>({
      table: DynamoTable.entityWorkflows,
      key: {
        [dynamoTables.ENTITY_WORKFLOWS_PK]: workflowItem.entityId,
        [dynamoTables.ENTITY_WORKFLOWS_SK]: workflowItem.compositeSk,
      }
    });

    if (fetchStatus !== "success" || !latestWorkflow) {
      throw new Error(`Unable to fetch workflow ${workflowItem.workflowId} for onComplete`);
    }

    // Check if workflow is already in a terminal state
    const isAlreadyTerminal = [
      Workflows.WorkflowStatus.Completed,
      Workflows.WorkflowStatus.Error,
      Workflows.WorkflowStatus.Stopped
    ].includes(latestWorkflow.status);

    // If already terminal, nothing to do
    if (isAlreadyTerminal) {
      return;
    }

    // Handle Restarted case - don't interfere with new workflow instance
    if (exitStatus === Workflows.ExitStatus.Restarted) {
      return;
    }

    // Map exit status to end state
    let endState: "finish" | "stop" | "error";
    switch (exitStatus) {
      case Workflows.ExitStatus.Completed:
        endState = "finish";
        break;
      case Workflows.ExitStatus.Error:
        endState = "error";
        break;
      case Workflows.ExitStatus.Stopped:
        endState = "stop";
        break;
      default:
        const exhaustiveCheck: never = exitStatus;
        throw new Error(`Unhandled ExitStatus case: ${exhaustiveCheck}`);
    }

    // Use the existing endWorkflow function to handle status update and resource cleanup
    const { status: endWorkflowStatus } = await endWorkflow<Workflows.WorkflowItem>({
      ctx,
      workflow: latestWorkflow,
      endState,
      stopReason: exitStatus === Workflows.ExitStatus.Stopped ? "workflow stopped" : undefined,
      updates: {}
    });

    if (endWorkflowStatus !== "success") {
      throw new Error(`Failed to end workflow ${workflowItem.workflowId} with exit status ${exitStatus}`);
    }

  } catch (error) {
    console.error(`Error in onComplete for workflow ${workflowItem.workflowId}:`, error);
    throw error;
  }
}